---
description: '仕様駆動ワークフローv1は、要件が明確に定義され、設計が綿密に計画され、実装が徹底的に文書化および検証されることを保証する、構造化されたソフトウェア開発アプローチを提供します。'
applyTo: '**'
---
# 仕様駆動ワークフロー v1

**仕様駆動ワークフロー:**
要件と実装のギャップを埋める。

**常に以下の成果物を維持する:**

- **`docs/spec/requirements.md`**: 構造化されたEARS記法でのユーザーストーリーと受け入れ基準。
- **`docs/spec/design.md`**: 技術アーキテクチャ、シーケンス図、実装上の考慮事項。
- **`docs/spec/tasks.md`**: 詳細かつ追跡可能な実装計画。

## 普遍的ドキュメンテーションフレームワーク

**ドキュメンテーションルール:**
詳細なテンプレートを、すべてのドキュメンテーションの**主要な真実の源**として使用する。

**言語ルール:**
すべてのドキュメンテーション成果物（`requirements.md`、`design.md`、`tasks.md`）およびテンプレートは日本語で生成する必要があります。

**サマリー形式:**
変更履歴やプルリクエストの説明など、簡潔な成果物にのみ使用する。

### 詳細ドキュメンテーションテンプレート

#### アクションドキュメンテーションテンプレート（すべてのステップ/実行/テスト）

```bash
### [TYPE] - [ACTION] - [TIMESTAMP]
**目的**: [達成される目標]
**コンテキスト**: [現在の状態、要件、および以前のステップへの参照]
**決定**: [選択されたアプローチと理論的根拠、該当する場合は決定記録を参照]
**実行**: [使用されたパラメータとコマンドを含む実行されたステップ。コードの場合、ファイルパスを含める。]
**出力**: [完全かつ省略されていない結果、ログ、コマンド出力、およびメトリクス]
**検証**: [成功検証方法と結果。失敗した場合は、修正計画を含める。]
**次のステップ**: [次の特定のアクションへの自動継続計画]
```

#### 決定記録テンプレート（すべての決定）

```bash
### 決定 - [TIMESTAMP]
**決定**: [決定されたこと]
**コンテキスト**: [決定を必要とする状況とそれを推進するデータ]
**オプション**: [評価された代替案と簡潔な長所と短所]
**理論的根拠**: [選択されたオプションが優れている理由、トレードオフを明示的に述べる]
**影響**: [実装、保守性、およびパフォーマンスに対する予想される結果]
**レビュー**: [この決定を再評価する条件またはスケジュール]
```

### サマリー形式（レポート用）

#### 簡略化されたアクションログ

簡潔な変更履歴を生成するため。各ログエントリは、完全なアクションドキュメントから派生しています。

`[TYPE][TIMESTAMP] 目標: [X] → アクション: [Y] → 結果: [Z] → 次: [W]`

#### 圧縮された決定記録

プルリクエストのサマリーまたはエグゼクティブサマリーで使用するため。

`決定: [X] | 理論的根拠: [Y] | 影響: [Z] | レビュー: [Date]`

## 実行ワークフロー（6フェーズループ）

**ステップを決してスキップしない。一貫した用語を使用する。曖昧さを減らす。**

### **フェーズ1: 分析（ANALYZE）**

**目的:**

- 問題を理解する。
- 既存のシステムを分析する。
- 明確でテスト可能な要件セットを作成する。
- 可能な解決策とその影響について考える。

**チェックリスト:**

- [ ] 提供されたすべてのコード、ドキュメント、テスト、およびログを読む。
      - ファイルインベントリ、サマリー、および初期分析結果を文書化する。
- [ ] **EARS記法**で要件を定義する:
      - 機能リクエストを構造化されたテスト可能な要件に変換する。
      - 形式: `[条件またはイベント]のとき、システムは[期待される動作]すること`
- [ ] 依存関係と制約を特定する。
      - リスクと緩和戦略を含む依存関係グラフを文書化する。
- [ ] データフローと相互作用をマッピングする。
      - システム相互作用図とデータモデルを文書化する。
- [ ] エッジケースと障害をカタログ化する。
      - 包括的なエッジケースマトリックスと潜在的な障害ポイントを文書化する。
- [ ] 信頼度を評価する。
      - 要件の明確性、複雑性、および問題範囲に基づいて**信頼度スコア（0-100%）**を生成する。
      - スコアとその理論的根拠を文書化する。

**重要な制約:**

- **すべての要件が明確で文書化されるまで進めない。**

### **フェーズ2: 設計（DESIGN）**

**目的:**

- 包括的な技術設計と詳細な実装計画を作成する。

**チェックリスト:**

- [ ] **信頼度スコアに基づいた適応的実行戦略を定義する:**
  - **高信頼度（>85%）**
    - 包括的で段階的な実装計画を作成する。
    - プルーフ・オブ・コンセプトのステップをスキップする。
    - 完全で自動化された実装を進める。
    - 標準的な包括的ドキュメントを維持する。
  - **中信頼度（66–85%）**
    - **プルーフ・オブ・コンセプト（PoC）**または**最小実用製品（MVP）**を優先する。
    - PoC/MVPの明確な成功基準を定義する。
    - 最初にPoC/MVPを構築および検証し、その後計画を段階的に拡大する。
    - PoC/MVPの目標、実行、および検証結果を文書化する。
  - **低信頼度（<66%）**
    - 最初のフェーズを研究と知識構築に捧げる。
    - セマンティック検索を使用し、類似の実装を分析する。
    - 調査結果を研究文書に統合する。
    - 研究後に分析フェーズを再実行する。
    - 信頼度が低いままの場合のみエスカレーションする。

- [ ] **`design.md`に技術設計を文書化する:**
  - **アーキテクチャ:** コンポーネントと相互作用の高レベル概要。
  - **データフロー:** 図と説明。
  - **インターフェース:** APIコントラクト、スキーマ、公開関数シグネチャ。
  - **データモデル:** データ構造とデータベーススキーマ。

- [ ] **エラーハンドリングを文書化する:**
  - 手順と期待される応答を含むエラーマトリックスを作成する。

- [ ] **ユニットテスト戦略を定義する。**

- [ ] **`tasks.md`に実装計画を作成する:**
  - 各タスクには、説明、期待される結果、および依存関係を含める。

**重要な制約:**

- **設計と計画が完了し検証されるまで実装に進めない。**

### **フェーズ3: 実装（IMPLEMENT）**

**目的:**

- 設計と計画に従って本番品質のコードを記述する。

**チェックリスト:**

- [ ] 小さくテスト可能な単位でコードを記述する。
      - コード変更、結果、およびテストリンクで各増分を文書化する。
- [ ] 依存関係から上向きに実装する。
      - 解決順序、正当化、および検証を文書化する。
- [ ] 規約に従う。
      - 遵守と逸脱を決定記録で文書化する。
- [ ] 意味のあるコメントを追加する。
      - 「何を」ではなく、意図（「なぜ」）に焦点を当てる。
- [ ] 計画に従ってファイルを作成する。
      - ファイル作成ログを文書化する。
- [ ] タスクステータスをリアルタイムで更新する。

**重要な制約:**

- **すべての実装ステップが文書化されテストされるまでコードをマージまたはデプロイしない。**

### **フェーズ4: 検証（VALIDATE）**

**目的:**

- 実装がすべての要件と品質基準を満たしていることを確認する。

**チェックリスト:**

- [ ] 自動テストを実行する。
      - 出力、ログ、およびカバレッジレポートを文書化する。
      - 失敗の場合は、根本原因分析と修正を文書化する。
- [ ] 必要に応じて手動検証を実行する。
      - 手順、チェックリスト、および結果を文書化する。
- [ ] エッジケースとエラーをテストする。
      - 結果と正しいエラー処理の証拠を文書化する。
- [ ] パフォーマンスを検証する。
      - メトリクスを文書化し、重要なセクションをプロファイルする。
- [ ] 実行トレースをログする。
      - パス分析とランタイム動作を文書化する。

**重要な制約:**

- **すべての検証ステップが完了しすべての問題が解決されるまで進めない。**

### **フェーズ5: 振り返り（REFLECT）**

**目的:**

- コードベースを改善し、ドキュメントを更新し、パフォーマンスを分析する。

**チェックリスト:**

- [ ] 保守性のためにリファクタリングする。
      - 決定、変更前後の比較、および影響を文書化する。
- [ ] すべてのプロジェクトドキュメントを更新する。
      - すべてのREADME、図、およびコメントが最新であることを確認する。
- [ ] 潜在的な改善を特定する。
      - 優先順位付けされたバックログを文書化する。
- [ ] 成功基準を検証する。
      - 最終的な検証マトリックスを文書化する。
- [ ] メタ分析を実行する。
      - 効率性、ツール使用、およびプロトコル遵守について振り返る。
- [ ] 技術的負債の課題を自動作成する。
      - インベントリと修正計画を文書化する。

**重要な制約:**

- **すべてのドキュメントと改善アクションがログされるまでフェーズを終了しない。**

### **フェーズ6: 引き渡し（HANDOFF）**

**目的:**

- レビューとデプロイメントのために作業をパッケージ化し、次のタスクに移行する。

**チェックリスト:**

- [ ] エグゼクティブサマリーを生成する。
      - **圧縮された決定記録**形式を使用する。
- [ ] プルリクエストを準備する（該当する場合）:
    1. エグゼクティブサマリー。
    2. **簡略化されたアクションログ**からの変更履歴。
    3. 検証成果物と決定記録へのリンク。
    4. 最終的な`requirements.md`、`design.md`、および`tasks.md`へのリンク。
- [ ] ワークスペースを最終化する。
      - 中間ファイル、ログ、および一時的な成果物を`.agent_work/`にアーカイブする。
- [ ] 次のタスクに進む。
      - 移行または完了を文書化する。

**重要な制約:**

- **すべての引き渡しステップが完了し文書化されるまでタスクを完了とみなさない。**

## トラブルシューティングと再試行プロトコル

**エラー、曖昧さ、またはブロッカーに遭遇した場合:**

**チェックリスト:**

1. **再分析**:
   - 分析フェーズを再訪する。
   - すべての要件と制約が明確で完全であることを確認する。
2. **再設計**:
   - 設計フェーズを再訪する。
   - 必要に応じて技術設計、計画、または依存関係を更新する。
3. **再計画**:
   - 新しい調査結果に対処するために`tasks.md`の実装計画を調整する。
4. **実行の再試行**:
   - 修正されたパラメータまたはロジックで失敗したステップを再実行する。
5. **エスカレーション**:
   - 再試行後も問題が続く場合は、エスカレーションプロトコルに従う。

**重要な制約:**

- **未解決のエラーまたは曖昧さで進めない。常にトラブルシューティングのステップと結果を文書化する。**

## 技術的負債管理（自動化）

### 識別とドキュメンテーション

- **コード品質**: 静的解析を使用して実装中にコード品質を継続的に評価する。
- **ショートカット**: スピード優先の決定とその結果をすべて決定記録に明示的に記録する。
- **ワークスペース**: 組織的なずれと命名の不整合を監視する。
- **ドキュメンテーション**: 不完全、古い、または欠落しているドキュメントを追跡する。

### 自動課題作成テンプレート

```text
**タイトル**: [技術的負債] - [簡単な説明]
**優先度**: [ビジネスインパクトと修正コストに基づくHigh/Medium/Low]
**場所**: [ファイルパスと行番号]
**理由**: [負債が発生した理由、利用可能な場合は決定記録へのリンク]
**影響**: [現在および将来の結果（例：開発速度の低下、バグリスクの増加）]
**修正**: [具体的で実行可能な解決ステップ]
**工数**: [解決のための見積もり（例：Tシャツサイズ：S、M、L）]
```

### 修正（自動優先順位付け）

- 依存関係分析を伴うリスクベースの優先順位付け。
- 将来の計画を支援するための工数見積もり。
- 大規模なリファクタリング作業のための移行戦略を提案する。

## 品質保証（自動化）

### 継続的監視

- **静的解析**: コードスタイル、品質、セキュリティ脆弱性、およびアーキテクチャルールの遵守のためのリンティング。
- **動的解析**: ステージング環境でのランタイム動作とパフォーマンスの監視。
- **ドキュメンテーション**: ドキュメントの完全性と正確性の自動チェック（例：リンク、形式）。

### 品質メトリクス（自動追跡）

- コードカバレッジ率とギャップ分析。
- 関数/メソッドごとの循環的複雑度スコア。
- 保守性インデックス評価。
- 技術的負債比率（例：推定修正時間対開発時間）。
- ドキュメントカバレッジ率（例：コメント付きのパブリックメソッド）。

## EARS記法リファレンス

**EARS（Easy Approach to Requirements Syntax）** - 要件の標準形式:

- **普遍的**: `システムは[期待される動作]すること`
- **イベント駆動**: `[トリガーイベント]のとき、システムは[期待される動作]すること`
- **状態駆動**: `[特定の状態]の間、システムは[期待される動作]すること`
- **望ましくない動作**: `[望ましくない条件]の場合、システムは[必要な応答]すること`
- **オプション**: `[機能が含まれる]場合、システムは[期待される動作]すること`
- **複雑**: 洗練された要件のための上記パターンの組み合わせ

各要件は以下を満たす必要がある:

- **テスト可能**: 自動または手動テストで検証可能
- **明確**: 単一の解釈のみ可能
- **必要**: システムの目的に貢献する
- **実現可能**: 制約内で実装可能
- **追跡可能**: ユーザーニーズと設計要素にリンクされている